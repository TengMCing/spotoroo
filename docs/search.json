[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 spotoroo authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"data-requirements","dir":"Articles","previous_headings":"","what":"Data requirements","title":"Guide to spotoroo","text":"order use spatiotemporal clustering algorithm provided spotoroo package, satellite hot spot data needs stored list least three fields: observed time, longitude latitude. observed time needs object inherited one classes: Date POSIXlt POSIXct numeric Besides, longitude latitude needs numeric. Using built-dataset hotspots example, data.frame lon (longitude) numeric column, lat (latitude) numeric column obsTime (observed time) POSIXct column. dataset contains 1070 selected hot spots Victoria (Australia) 2019-2020 Australian bushfire season. details dataset can found using function help(hotspots)","code":"str(hotspots) #> 'data.frame':    1070 obs. of  3 variables: #>  $ lon    : num  147 146 143 149 142 ... #>  $ lat    : num  -37.5 -37.9 -37.8 -37.4 -37.1 ... #>  $ obsTime: POSIXct, format: \"2020-02-01 05:20:00\" \"2020-01-02 06:30:00\" ..."},{"path":"/articles/Clustering-hot-spots.html","id":"overview-of-the-hot-spot-data","dir":"Articles","previous_headings":"","what":"Overview of the hot spot data","title":"Guide to spotoroo","text":"common way get better understanding hot spot data visualize . package provides function plot_vic_map() (package sf needs installed) draw map Victoria. returns ggplot object, new layers added onto . use geom_point() draw red dots hot spots. map, observe approximately \\(4\\) clusters, don’t know can broken clusters. goal cluster hot spots fires temporal spatial manner.  like visualize hot spots areas, might able find spatial data rnaturalearth package make similar map using geom_sf() ggthemes::theme_map() function. example given .","code":"library(ggplot2)  if (requireNamespace(\"sf\", quietly = TRUE)) {     plot_vic_map() +     geom_point(data = hotspots, aes(lon, lat), col = \"red\") } # NOT RUN ggplot() +   geom_sf(data = your_map, aes(geometry = geometry)) +   geom_point(data = your_hotspots, aes(lon, lat), col = \"red\") +   ggthemes::theme_map()"},{"path":"/articles/Clustering-hot-spots.html","id":"spatiotemporal-clustering-of-hot-spot","dir":"Articles","previous_headings":"","what":"Spatiotemporal clustering of hot spot","title":"Guide to spotoroo","text":"hotspot_cluster() main function package. cases, need use function perform spatiotemporal clustering algorithm.","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"arguments","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot","what":"Arguments","title":"Guide to spotoroo","text":"function \\(11\\) arguments, can divided four categories:","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"specifications-of-the-dataset","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot > Arguments","what":"1. specifications of the dataset","title":"Guide to spotoroo","text":"first four arguments pretty straight forward, need provide dataset object corresponding column names.","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"specifications-of-the-parameters-of-the-clustering-algorithm","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot > Arguments","what":"2. specifications of the parameters of the clustering algorithm","title":"Guide to spotoroo","text":"four arguments control clustering process. activeTime interpreted time fire can stay smouldering undetectable satellite flaring . example, activeTime \\(= 24\\), time tolerance \\(24\\) time indexes. adjDist interpreted maximum intra-cluster distance hot spot nearest hot spot. example, adjDist \\(= 3\\), distance tolerance \\(3\\) km. However, special cases, intra-cluster distance hot spot nearest hot spot exceed threshold. can learn parameter algorithm using help(hotspot_cluster) function. minPts minimum number hot spots cluster. example, minPts \\(4\\), cluster less \\(4\\) hot spots treated noise. minTime minimum length time cluster. example, minTime \\(3\\), cluster lasts shorter \\(3\\) time indexes treated noise. practice, usually don’t knowledge parameters activeTime adjDist, general, number clusters decrease increase two parameters. Comparing clustering results different settings available method determine two parameters. show section Additional topic: Choice parameters. terms minPts minTime, depend personal preference noise reduction. , number clusters often decrease increase two parameters. sensible choice two parameters minPts \\(\\[3,10]\\) minTime \\(\\[1~hour, 12~hours]\\)","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"specification-of-the-calculation-of-the-ignition-points","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot > Arguments","what":"3. specification of the calculation of the ignition points","title":"Guide to spotoroo","text":"cluster, ignitionCenter “mean”, centroid earliest hot spots used ignition point, ignitionCenter “median”, median longitude median latitude hot spots used ignition point. usual, significant difference two methods, recommend set ignitionCenter = \"mean\".","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"specifications-of-the-transformation-of-the-observed-time","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot > Arguments","what":"4. specifications of the transformation of the observed time","title":"Guide to spotoroo","text":"Due design algorithm, observed time needs transformed discrete time index. Available time units “d” (days), “h” (hours), “m” (minutes), “s” (seconds) “n” (numeric). timeUnit = \"n\" accepted observed time already numeric vector. example, timeUnit “h” timeStep \\(2\\), difference time index \\(1\\) time index \\(2\\) \\(2\\) hours.","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"usage","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot","what":"Usage","title":"Guide to spotoroo","text":"specifications arguments, hotspot_cluster() can used . Generally, need use object catch return. Messages produced function tell important information clustering results number discrete time indexes, number clusters proportion noise. like silent function, wrap function suppressMessages() function like example given .","code":"result <- hotspot_cluster(hotspots = hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\" #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots #> ℹ 0.001 secs per hot spot #>  #> ──────────────────────────────────────────────────────────────────────────────── # NOT RUN suppressMessages(hotspot_cluster())"},{"path":"/articles/Clustering-hot-spots.html","id":"returns","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot","what":"Returns","title":"Guide to spotoroo","text":"hotspot_cluster() function returns spotoroo object, actually list contains data.frame called hotpsots, data.frame called ignition list called setting. evaluate result print , get concise description clustering results. , according output, know \\(6\\) clusters clustering results. can access two data.frames usual way. hotspots dataset contains information hot spot. Particularly, membership column membership label column. \\(-1\\) represents noise. ignition dataset contains information cluster. Similarly, membership column membership label column. lon lat coordinate information ignition points.","code":"result #> ℹ spotoroo object: 6 clusters | 1070 hot spots (including noise points) head(result$hotspots, 2) #>      lon       lat             obsTime timeID membership noise distToIgnition #> 1 147.46 -37.46000 2020-02-01 05:20:00    809         -1  TRUE              0 #> 2 146.48 -37.93999 2020-01-02 06:30:00     90         -1  TRUE              0 #>   distToIgnitionUnit timeFromIgnition timeFromIgnitionUnit #> 1                  m          0 hours                    h #> 2                  m          0 hours                    h  head(result$ignition, 2) #>   membership    lon    lat             obsTime timeID obsInCluster #> 1          1 149.30 -37.77 2019-12-29 13:10:00      1          146 #> 2          2 146.72 -36.84 2020-01-08 01:40:00    229          165 #>   clusterTimeLen clusterTimeLenUnit #> 1 116.1667 hours                  h #> 2 148.3333 hours                  h"},{"path":"/articles/Clustering-hot-spots.html","id":"extract-a-subset-of-clusters","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot > Returns","what":"Extract a subset of clusters","title":"Guide to spotoroo","text":"like extract subset clusters results merge hotspots ignition dataset, use function extract_fire(). choose extract clusters along noise points setting cluster = \"\" noise = TRUE. merge hotspots ignition dataset. also extract subset clusters without noise providing vector membership labels argument cluster set noise = FALSE. merge hotspots ignitoin dataset filtering noise points selecting needed clusters.","code":"# Merge the `hotspots` and `ignition` dataset merged_result <- extract_fire(result, cluster = \"all\", noise = TRUE) # Merge the `hotspots` and `ignition` dataset # Select cluster 2 and 3 and filter out noise cluster_2_and_3 <- extract_fire(result, cluster = c(2, 3), noise = FALSE)"},{"path":"/articles/Clustering-hot-spots.html","id":"additional-topic-choice-of-parameters","dir":"Articles","previous_headings":"Spatiotemporal clustering of hot spot","what":"Additional topic: Choice of parameters","title":"Guide to spotoroo","text":"principal, parameters activeTime adjDist determined using professional knowledge fire behaviour, practice, generally don’t know much . rest section, show one methods choose proper values two parameters. first set minPts = 4 minTime = 3. set different values minPts minTime like. grid search activeTime adjDist sensible range. , set adjDist \\(\\\\) [500,1000,1500,2000,2500,3000,3500,4000] activeTime \\(\\\\) [6,12,18,24,30,36,42,48]. pair activeTime adjDist, record proportion noise metric comparison. following code calculation. may takes around 10 minutes run. try like. proportion noise, make two line plots reveal relationships proportion noise, adjDist activeTime. works like scree plot used principal component analysis. want keep clusters separate without introducing much noise. first plot, significant drops proportion noise observed adjDist less 2500 metres. Therefore, adjDist = 2500 reasonable choice.  second plot, significant drops proportion noise observed activeTime less 24 hours. Therefore, activeTime = 24 reasonable choice.","code":"# NOT RUN # NOTICE: MAY TAKE AROUND 10 MINS TO RUN THIS CODE BLOCK noise_prop <- c()  for (adjDist in seq(500, 4000, 500)) {   for (activeTime in seq(6, 48, 6)) {     result <- suppressMessages(hotspot_cluster(hotspots = hotspots,                                                lon = \"lon\",                                                lat = \"lat\",                                                obsTime = \"obsTime\",                                                activeTime = activeTime,                                                adjDist = adjDist,                                                minPts = 4,                                                minTime = 3,                                                ignitionCenter = \"mean\",                                                timeUnit = \"h\",                                                timeStep = 1))          noise_prop <- c(noise_prop, mean(result$hotspots$noise))   } }  tab <- expand.grid(activeTime = seq(6, 48, 6),                    adjDist = seq(500, 4000, 500))  tab$noise_prop <- noise_prop ggplot(tab) +   geom_line(aes(adjDist, noise_prop, color = as.factor(activeTime))) +   ylab(\"Noise Propotion\") +   labs(col = \"activeTime\") +   theme_minimal() +   scale_x_continuous(breaks = seq(500, 4000, 500)) ggplot(tab) +   geom_line(aes(activeTime, noise_prop, color = as.factor(adjDist))) +   ylab(\"Noise Propotion\") +   labs(col = \"adjDist\") +   theme_minimal() +   scale_x_continuous(breaks = seq(6, 48, 6))"},{"path":"/articles/Clustering-hot-spots.html","id":"exploring-the-spatiotemporal-clustering-results","dir":"Articles","previous_headings":"","what":"Exploring the spatiotemporal clustering results","title":"Guide to spotoroo","text":"package provides useful functions explore clustering results.","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"summary","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results","what":"Summary","title":"Guide to spotoroo","text":"make brief summary clustering results. make brief summary subset clusters providing vector membership labels cluster argument.","code":"summary_spotoroo(result) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: ALL #> OBSERVATIONS: 1070 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-07 22:50:00 #>  #> ── Clusters #> ℹ Number of clusters: 6 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.0       131.0       176.7       233.2       256.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.2       118.2       131.9       146.1       148.3 #>  #> ── Hot spots (excluding noise) #> ℹ Number of hot spots: 1060 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2840.3      5058.2      6981.6     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        25.2        62.5        98.2       148.3 #>  #> ── Noise #> ℹ Number of noise points: 10 (0.93 %) #>  #> ──────────────────────────────────────────────────────────────────────────────── summary_spotoroo(result, cluster = c(1, 3, 4))"},{"path":"/articles/Clustering-hot-spots.html","id":"called-by-summary","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Summary","what":"Called by summary()","title":"Guide to spotoroo","text":"convenience, summary_spotoroo() can called summary() function.","code":"summary(result) summary(result, cluster = c(1, 3, 4))"},{"path":"/articles/Clustering-hot-spots.html","id":"plot","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results","what":"Plot","title":"Guide to spotoroo","text":"produce plot clustering results. three types plots, “def” (default), “mov” (fire movement) “timeline” (timeline).","code":""},{"path":"/articles/Clustering-hot-spots.html","id":"default","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Plot","what":"Default","title":"Guide to spotoroo","text":"","code":"plot_spotoroo(result, type = \"def\")"},{"path":"/articles/Clustering-hot-spots.html","id":"timeline","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Plot","what":"Timeline","title":"Guide to spotoroo","text":"","code":"plot_spotoroo(result, type = \"timeline\") #> ℹ `plot_timeline()`: Package ggbeeswarm version is not 0.6.0. `geom_point()` will be used insted to draw noise."},{"path":"/articles/Clustering-hot-spots.html","id":"fire-movement","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Plot","what":"Fire movement","title":"Guide to spotoroo","text":"fire movement calculated get_fire_mov() function.","code":"plot_spotoroo(result, type = \"mov\", step = 6)"},{"path":"/articles/Clustering-hot-spots.html","id":"add-a-background","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Plot","what":"Add a background","title":"Guide to spotoroo","text":"background ggplot object, can let function plots onto .   details usage function can found using help(plot_spotoroo) function.","code":"if (requireNamespace(\"sf\", quietly = TRUE)) {   plot_spotoroo(result, bg = plot_vic_map()) } if (requireNamespace(\"sf\", quietly = TRUE)) {   plot_spotoroo(result, type = \"mov\", bg = plot_vic_map(), step = 6) }"},{"path":"/articles/Clustering-hot-spots.html","id":"called-by-plot","dir":"Articles","previous_headings":"Exploring the spatiotemporal clustering results > Plot","what":"Called by plot()","title":"Guide to spotoroo","text":"convenience, plot_spotoroo() can called plot() function.","code":"plot(result) plot(result, type = \"timeline\") plot(result, type = \"mov\") plot(result, bg = plot_vic_map()) plot(result, type = \"mov\", bg = plot_vic_map())"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Weihao Li. Author, maintainer. Di Cook. Contributor. Emily Dodwell. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Weihao Li, Dianne Cook Emily Dodwell (2021). spotoroo: Spatiotemporal Clustering Satellite Hot Spot Data. https://cran.r-project.org/web/packages/spotoroo/index.html","code":"@Misc{,   author = {Weihao Li and Dianne Cook and Emily Dodwell},   title = {spotoroo: Spatiotemporal Clustering of Satellite Hot Spot Data},   year = {2021},   url = {https://cran.r-project.org/web/packages/spotoroo/index.html}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Spatiotemporal Clustering of Satellite Hot Spot Data","text":"“spotoroo” stands spatiotemporal clustering R hot spot data. algorithm cluster satellite hot spots, detect ignition points reconstruct fire movement.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatiotemporal Clustering of Satellite Hot Spot Data","text":"can install released version spotoroo CRAN : can install development version GitHub :","code":"install.packages(\"spotoroo\") # install.packages(\"devtools\") devtools::install_github(\"TengMCing/spotoroo\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Spatiotemporal Clustering of Satellite Hot Spot Data","text":"examples use built-dataset hotspots. hot spot data needs least three columns: longitude, latitude, observed time. Perform spatiotemporal clustering dataset. need specify columns correspond spatial variables (“lon”, “lat”), observed time (“obsTime”). choice options algorithm. “activeTime” sets time consider fire can active, longer hot spots create new cluster “adjDist” sets maximum intra-cluster spatial distance nearest hot spots beyond considered part different cluster “minPts” sets minimum number hot spots cluster “minTime” sets minimum length time cluster “ignitionCenter” sets method calculate ignition points “timeUnit” “timeStep” set length time successive time indexes can make summary clustering results. can extract subset clusters results. Plot result. example, total 6 clusters, can displayed.  can also choose subset clusters, plot without map, can see zoomed view hot spot clusters ignition points.  examine fire movements, use option “mov”, movement shown connected lines centroids time step, cluster.  examine time line clusters learn intensity fire periods, use option “timeline”.","code":"library(spotoroo) str(hotspots) #> 'data.frame':    1070 obs. of  3 variables: #>  $ lon    : num  147 146 143 149 142 ... #>  $ lat    : num  -37.5 -37.9 -37.8 -37.4 -37.1 ... #>  $ obsTime: POSIXct, format: \"2020-02-01 05:20:00\" \"2020-01-02 06:30:00\" ... result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── '1' time index = 1 hours #> ✓ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters #> ✓ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes #> ✓ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : '0.935 %' #>  #> ── ignitionCenter = 'mean' #> ✓ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────   result #> ℹ spotoroo object: 6 clusters | 1070 hot spots (including noise points) summary(result) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: ALL #> OBSERVATIONS: 1070 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-07 22:50:00 #>  #> ── Clusters #> ℹ Number of clusters: 6 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.0       131.0       176.7       233.2       256.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.2       118.2       131.9       146.1       148.3 #>  #> ── Hot spots (excluding noise) #> ℹ Number of hot spots: 1060 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2840.3      5058.2      6981.6     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        25.2        62.5        98.2       148.3 #>  #> ── Noise #> ℹ Number of noise points: 10 ('0.93 %') #>  #> ──────────────────────────────────────────────────────────────────────────────── fire_1_and_2 <- extract_fire(result, 1:2) head(fire_1_and_2, 2) #>     lon       lat             obsTime timeID membership noise distToIgnition #> 1 149.3 -37.75999 2019-12-29 13:10:00      1          1 FALSE       1111.885 #> 2 149.3 -37.78000 2019-12-29 13:10:00      1          1 FALSE       1111.885 #>   distToIgnitionUnit timeFromIgnition timeFromIgnitionUnit    type obsInCluster #> 1                  m          0 hours                    h hotspot          146 #> 2                  m          0 hours                    h hotspot          146 #>   clusterTimeLen clusterTimeLenUnit #> 1 116.1667 hours                  h #> 2 116.1667 hours                  h plot(result, bg = plot_vic_map()) plot(result, cluster = c(1,2,3,4)) plot(result,    type = \"mov\",    cluster = 1:3,    step = 6,    bg = plot_vic_map()) plot(result, \"timeline\",       dateLabel = \"%b %d\",       mainBreak = \"1 week\")"},{"path":"/reference/dist_point_to_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","title":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","text":"function calculates geodesic point multiple points given coordinate information. wrapper geodist::geodist_vec().","code":""},{"path":"/reference/dist_point_to_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","text":"","code":"dist_point_to_vector(plon, plat, vlon, vlat)"},{"path":"/reference/dist_point_to_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","text":"plon Numeric. longitude point. plat Numeric. latitude point. vlon Numeric. vector longitude values. vlat Numeric. vector latitude values.","code":""},{"path":"/reference/dist_point_to_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","text":"Numeric. geodesic point multiple points meters.","code":""},{"path":"/reference/dist_point_to_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculation of the geodesic of a point to multiple points — dist_point_to_vector","text":"","code":"# Define vlon and vlat vlon <- c(141.12, 141.13) vlat <- c(-37.1, -37.0)  # Calculate the geodesic dist_point_to_vector(141.12, -37.1, vlon, vlat) #> [1]     0.00 11148.63"},{"path":"/reference/extract_fire.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting fires from the spatiotemporal clustering results — extract_fire","title":"Extracting fires from the spatiotemporal clustering results — extract_fire","text":"function takes spotoroo object produce data frame contains information fire.","code":""},{"path":"/reference/extract_fire.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting fires from the spatiotemporal clustering results — extract_fire","text":"","code":"extract_fire(result, cluster = \"all\", noise = FALSE)"},{"path":"/reference/extract_fire.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting fires from the spatiotemporal clustering results — extract_fire","text":"result spotoroo object. result call hotspot_cluster(). cluster Character/Integer. \"\", extract clusters. integer vector given, extract corresponding clusters. noise Logical. Whether include noise.","code":""},{"path":"/reference/extract_fire.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting fires from the spatiotemporal clustering results — extract_fire","text":"data.frame. fire information lon : Longitude. lat : Latitude. obsTime : Observed time. timeID : Time indexes. membership : Membership labels. noise : Whether noise point. distToIgnition : Distance ignition location. distToIgnitionUnit : Unit distance ignition location. timeFromIgnition : Time ignition. timeFromIgnitionUnit : Unit time ignition. type : Type entry, either \"hotspot\", \"noise\" \"ignition\" obsInCluster : Number observations cluster. clusterTimeLen : Length time cluster. clusterTimeLenUnit : Unit length time cluster.","code":""},{"path":"/reference/extract_fire.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracting fires from the spatiotemporal clustering results — extract_fire","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────     # Extract all fires   all_fires <- extract_fire(result)   head(all_fires, 3) #>      lon       lat             obsTime timeID membership noise distToIgnition #> 1 149.30 -37.75999 2019-12-29 13:10:00      1          1 FALSE       1111.885 #> 2 149.30 -37.78000 2019-12-29 13:10:00      1          1 FALSE       1111.885 #> 3 149.32 -37.78000 2019-12-29 13:30:00      1          1 FALSE       2080.914 #>   distToIgnitionUnit timeFromIgnition timeFromIgnitionUnit    type obsInCluster #> 1                  m  0.0000000 hours                    h hotspot          146 #> 2                  m  0.0000000 hours                    h hotspot          146 #> 3                  m  0.3333333 hours                    h hotspot          146 #>   clusterTimeLen clusterTimeLenUnit #> 1 116.1667 hours                  h #> 2 116.1667 hours                  h #> 3 116.1667 hours                  h    # Extract cluster 4   fire_4 <- extract_fire(result, 4)   head(fire_4, 3) #>      lon       lat             obsTime timeID membership noise distToIgnition #> 1 149.16 -37.25999 2020-01-10 04:10:00    280          4 FALSE       3334.822 #> 2 149.16 -37.28000 2020-01-10 04:10:00    280          4 FALSE       1111.052 #> 3 149.16 -37.30000 2020-01-10 04:10:00    280          4 FALSE       1111.607 #>   distToIgnitionUnit timeFromIgnition timeFromIgnitionUnit    type obsInCluster #> 1                  m          0 hours                    h hotspot          256 #> 2                  m          0 hours                    h hotspot          256 #> 3                  m          0 hours                    h hotspot          256 #>   clusterTimeLen clusterTimeLenUnit #> 1 124.1667 hours                  h #> 2 124.1667 hours                  h #> 3 124.1667 hours                  h # }"},{"path":"/reference/get_fire_mov.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculation of the fire movement — get_fire_mov","title":"Calculation of the fire movement — get_fire_mov","text":"function calculates movement single fire per step time indexes. collects hot spots per step time indexes, takes mean median longitude latitude centre fire.","code":""},{"path":"/reference/get_fire_mov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculation of the fire movement — get_fire_mov","text":"","code":"get_fire_mov(result, cluster, step = 1, method = \"mean\")"},{"path":"/reference/get_fire_mov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculation of the fire movement — get_fire_mov","text":"result spotoroo object. result call hotspot_cluster(). cluster Integer. membership label cluster. step Integer (>0). Step size used calculation fire movement. method Character. Either \"mean\" \"median\", method calculation centre fire.","code":""},{"path":"/reference/get_fire_mov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculation of the fire movement — get_fire_mov","text":"data.frame. fire movement. membership : Membership labels. lon : Longitude centre fire. lat : Latitude centre fire. timeID : Time indexes. obsTime : Observed time (approximated). ignition : Whether ignition point.","code":""},{"path":"/reference/get_fire_mov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculation of the fire movement — get_fire_mov","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Get fire movement of the first cluster   mov1 <- get_fire_mov(result, cluster = 1, step = 3, method = \"mean\")   mov1 #>    membership      lon       lat timeID             obsTime ignition #> 1           1 149.3000 -37.77000      1 2019-12-29 13:10:00     TRUE #> 2           1 149.3067 -37.77778      4 2019-12-29 17:00:00    FALSE #> 3           1 149.3133 -37.77333      7 2019-12-29 19:20:00    FALSE #> 4           1 149.3100 -37.77000     10 2019-12-29 22:50:00    FALSE #> 5           1 149.2900 -37.77000     24 2019-12-30 12:40:00    FALSE #> 6           1 149.2867 -37.75333     42 2019-12-31 06:50:00    FALSE #> 7           1 149.2850 -37.75249     45 2019-12-31 09:10:00    FALSE #> 8           1 149.2800 -37.74999     48 2019-12-31 12:40:00    FALSE #> 9           1 149.2800 -37.74999     51 2019-12-31 15:50:00    FALSE #> 10          1 149.2800 -37.75199     54 2019-12-31 18:10:00    FALSE #> 11          1 149.2733 -37.76666     65 2020-01-01 05:50:00    FALSE #> 12          1 149.2767 -37.75500     68 2020-01-01 09:00:00    FALSE #> 13          1 149.2767 -37.74999     71 2020-01-01 12:00:00    FALSE #> 14          1 149.2800 -37.74999     74 2020-01-01 14:50:00    FALSE #> 15          1 149.2800 -37.74500     77 2020-01-01 17:20:00    FALSE #> 16          1 149.2720 -37.74800     87 2020-01-02 03:20:00    FALSE #> 17          1 149.2627 -37.75181     90 2020-01-02 07:00:00    FALSE #> 18          1 149.2588 -37.74823     93 2020-01-02 10:00:00    FALSE #> 19          1 149.2617 -37.74333     97 2020-01-02 14:00:00    FALSE #> 20          1 149.2625 -37.75249    113 2020-01-03 05:40:00    FALSE #> 21          1 149.2400 -37.75999    116 2020-01-03 08:50:00    FALSE    # Get fire movement of the second cluster   mov2 <- get_fire_mov(result, cluster = 2, step = 6, method = \"median\")   mov2 #>    membership    lon    lat timeID             obsTime ignition #> 1           2 146.72 -36.84    229 2020-01-08 01:40:00     TRUE #> 2           2 146.72 -36.84    235 2020-01-08 08:00:00    FALSE #> 3           2 146.72 -36.82    241 2020-01-08 14:00:00    FALSE #> 4           2 146.72 -36.82    254 2020-01-09 03:00:00    FALSE #> 5           2 146.72 -36.80    260 2020-01-09 08:20:00    FALSE #> 6           2 146.72 -36.84    282 2020-01-10 06:10:00    FALSE #> 7           2 146.76 -36.86    304 2020-01-11 05:00:00    FALSE #> 8           2 146.76 -36.86    310 2020-01-11 11:00:00    FALSE #> 9           2 146.78 -36.90    327 2020-01-12 04:00:00    FALSE #> 10          2 146.78 -36.90    334 2020-01-12 10:10:00    FALSE #> 11          2 146.78 -36.89    359 2020-01-13 11:30:00    FALSE #> 12          2 146.82 -36.86    377 2020-01-14 06:00:00    FALSE # }"},{"path":"/reference/global_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering hot spots spatially and temporally — global_clustering","title":"Clustering hot spots spatially and temporally — global_clustering","text":"function clusters hot spots spatially temporally.","code":""},{"path":"/reference/global_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering hot spots spatially and temporally — global_clustering","text":"","code":"global_clustering(lon, lat, timeID, activeTime, adjDist)"},{"path":"/reference/global_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering hot spots spatially and temporally — global_clustering","text":"lon Numeric. vector longitude values. lat Numeric. vector latitude values. timeID Integer (>=1). vector time indexes. activeTime Numeric (>=0). Time tolerance. Unit time index. adjDist Numeric (>0). Distance tolerance. Unit metre.","code":""},{"path":"/reference/global_clustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering hot spots spatially and temporally — global_clustering","text":"Integer. vector membership labels.","code":""},{"path":"/reference/global_clustering.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clustering hot spots spatially and temporally — global_clustering","text":"details clustering algorithm arguments activeTime adjDist, please check documentation hotspot_cluster(). function performs first 3 steps clustering algorithm.","code":""},{"path":"/reference/global_clustering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering hot spots spatially and temporally — global_clustering","text":"","code":"# Define lon, lat and timeID for 10 observations lon <- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,           141.16, 141.12, 141.14) lat <- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,          -37.14, -37.16, -37.16) timeID <- c(rep(1, 5), rep(26, 5))  # Cluster 10 hot spots with different values of activeTime and adjDist global_clustering(lon, lat, timeID, 12, 1500) #>  #> ── activeTime = 12 time indexes | adjDist = 1500 meters  #> ✔ Cluster #> ℹ 10 clusters found (including noise) #>  [1]  1  2  3  4  5  6  7  8  9 10 global_clustering(lon, lat, timeID, 24, 3000) #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 2 clusters found (including noise) #>  [1] 1 1 1 1 1 2 2 2 2 2 global_clustering(lon, lat, timeID, 36, 6000) #>  #> ── activeTime = 36 time indexes | adjDist = 6000 meters  #> ✔ Cluster #> ℹ 1 cluster found (including noise) #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"/reference/handle_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Handling noise in the clustering results — handle_noise","title":"Handling noise in the clustering results — handle_noise","text":"function finds noise clustering results label -1.","code":""},{"path":"/reference/handle_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handling noise in the clustering results — handle_noise","text":"","code":"handle_noise(global_membership, timeID, minPts, minTime)"},{"path":"/reference/handle_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handling noise in the clustering results — handle_noise","text":"global_membership Integer. vector membership labels. timeID Integer. vector time indexes. minPts Numeric (>0). Minimum number hot spots cluster. minTime Numeric (>=0). Minimum length time cluster. Unit time index.","code":""},{"path":"/reference/handle_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handling noise in the clustering results — handle_noise","text":"Integer. vector membership labels.","code":""},{"path":"/reference/handle_noise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handling noise in the clustering results — handle_noise","text":"details clustering algorithm arguments minPts minTime, please check documentation hotspot_cluster(). function performs step 4 clustering algorithm. uses given threshold (minimum number points minimum length time) find noise label -1.","code":""},{"path":"/reference/handle_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handling noise in the clustering results — handle_noise","text":"","code":"# Define membership labels and timeID for 10 observations global_membership <- c(1,1,1,2,2,2,2,2,2,3,3,3,3,3,3) timeID <- c(1,2,3,2,3,3,4,5,6,3,3,3,3,3,3)  # Handle noise with different values of minPts and minTime handle_noise(global_membership, timeID, 4, 0) #>  #> ── minPts = 4 hot spots | minTime = 0 time indexes  #> ✔ Handle noise #> ℹ 2 clusters left #> ℹ noise proportion : 20 % #>  [1] -1 -1 -1  1  1  1  1  1  1  2  2  2  2  2  2 handle_noise(global_membership, timeID, 4, 1) #>  #> ── minPts = 4 hot spots | minTime = 1 time index  #> ✔ Handle noise #> ℹ 1 cluster left #> ℹ noise proportion : 60 % #>  [1] -1 -1 -1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 handle_noise(global_membership, timeID, 3, 3) #>  #> ── minPts = 3 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 1 cluster left #> ℹ noise proportion : 60 % #>  [1] -1 -1 -1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1"},{"path":"/reference/hotspot_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatiotemporal clustering of hot spot data — hotspot_cluster","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"main function package.  function clusters hot spots fires. can used reconstruct fire history detect fire ignition points.","code":""},{"path":"/reference/hotspot_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"","code":"hotspot_cluster(   hotspots,   lon = \"lon\",   lat = \"lat\",   obsTime = \"obsTime\",   activeTime = 24,   adjDist = 3000,   minPts = 4,   minTime = 3,   ignitionCenter = \"mean\",   timeUnit = \"n\",   timeStep = 1 )"},{"path":"/reference/hotspot_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"hotspots List/Data frame. list data frame contains information hot spots. lon Character. name column list contains numeric longitude values. lat Character. name column list contains numeric latitude values. obsTime Character. name column list contains observed time hot spots. observed time date, datetime numeric. activeTime Numeric (>=0). Time tolerance. Unit time index. adjDist Numeric (>0). Distance tolerance. Unit metre. minPts Numeric (>0). Minimum number hot spots cluster. minTime Numeric (>=0). Minimum length time cluster. Unit time index. ignitionCenter Character. Method calculate ignition points, either \"mean\" \"median\". timeUnit Character. One \"s\" (seconds), \"m\" (minutes), \"h\" (hours), \"d\" (days) \"n\" (numeric). timeStep Numeric (>0). Number units timeUnit time step.","code":""},{"path":"/reference/hotspot_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"spotoroo object. clustering results. also list: hotspots : data frame contains information hot spots. lon : Longitude. lat : Latitude. obsTime : Observed time. timeID : Time index. membership : Membership label. noise : Whether noise point. distToIgnition : Distance ignition location. distToIgnitionUnit : Unit distance ignition location. timeFromIgnition : Time ignition. timeFromIgnitionUnit : Unit time ignition. ignition : data frame contains information ignition points. lon : Longitude. lat : Latitude. obsTime : Observed time. timeID : Time index. obsInCluster : Number observations cluster. clusterTimeLen : Length time cluster. clusterTimeLenUnit : Unit length time cluster. setting : list contains clustering settings.","code":""},{"path":"/reference/hotspot_cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"Arguments timeUnit timeStep need specified convert date/datetime/numeric time index. details can found transform_time_id().  clustering algorithm consisted 5 steps:  step 1, defines \\(T\\) intervals using time index $$Interval(t) = [max(1, t - activeTime),t]$$ \\(t = 1, 2, ..., T\\), \\(T\\) maximum time index. activeTime argument needs specified. represents maximum time difference two hot spots local cluster. Please notice local cluster different cluster final result. details given next part.  step 2, algorithm performs spatial clustering interval. local cluster cluster found interval. Argument adjDist used control spatial clustering. distance two hot spots smaller equal adjDist, directly-connected. hot spot directly-connected hot spot B hot spot B directly-connected hot spot C, hot spot , B C connected. connected hot spots become local cluster.  step 3, algorithm starts interval \\(1\\). marks hot spots interval records membership labels. moves interval \\(2\\). Due hot spot exist multiple intervals, checks whether hot spot interval \\(2\\) marked. , membership labels carried record. Unmarked hot spots interval \\(2\\), share local cluster marked hot spots, membership labels carried marked hot spots. unmarked hot spot shares local cluster multiple marked hot spots, algorithm carry membership label nearest one. unmarked hot spots interval \\(2\\) share cluster marked hot spot, membership labels adjusted clusters belong considered new clusters. Finally, hot spots interval \\(2\\) marked membership labels recorded. process continues interval \\(3\\), \\(4\\), ..., \\(T\\). finishing step 3, hot spots marked membership labels recorded.  step 4, checks cluster. cluster contains less minPts hot spots, lasts shorter minTime, considered cluster , hot spots assigned -1 membership labels. hot spot membership label -1 noise. Arguments minPts minTime need specified.  step 5, algorithm finds earliest observed hot spots cluster records ignition points. multiple earliest observed hot spots cluster, mean median longitude values latitude values used coordinate ignition point. needs specified argument ignitionCenter.","code":""},{"path":"/reference/hotspot_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatiotemporal clustering of hot spot data — hotspot_cluster","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                 lon = \"lon\",                 lat = \"lat\",                 obsTime = \"obsTime\",                 activeTime = 24,                 adjDist = 3000,                 minPts = 4,                 minTime = 3,                 ignitionCenter = \"mean\",                 timeUnit = \"h\",                 timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Make a summary of the clustering results   summary(result) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: ALL #> OBSERVATIONS: 1070 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-07 22:50:00 #>  #>  #> ── Clusters  #> ℹ Number of clusters: 6 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.0       131.0       176.7       233.2       256.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.2       118.2       131.9       146.1       148.3 #>  #> ── Hot spots (excluding noise)  #> ℹ Number of hot spots: 1060 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2840.3      5058.2      6981.6     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        25.2        62.5        98.2       148.3 #>  #> ── Noise  #> ℹ Number of noise points: 10 (0.93 %) #>  #>  #> ────────────────────────────────────────────────────────────────────────────────    # Make a plot of the clustering results   plot(result, bg = plot_vic_map())  # }"},{"path":"/reference/hotspots.html","id":null,"dir":"Reference","previous_headings":"","what":"1070 observations of satellite hot spots — hotspots","title":"1070 observations of satellite hot spots — hotspots","text":"dataset containing 1070 observations satellite hot spots Victoria, Australia 2019-2020 Australian bushfire season.","code":""},{"path":"/reference/hotspots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"1070 observations of satellite hot spots — hotspots","text":"","code":"hotspots"},{"path":"/reference/hotspots.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"1070 observations of satellite hot spots — hotspots","text":"data frame 1070 rows 3 variables: lon longitude lat latitude obsTime observed time","code":""},{"path":"/reference/hotspots.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"1070 observations of satellite hot spots — hotspots","text":"https://www.eorc.jaxa.jp/ptree/","code":""},{"path":"/reference/ignition_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculation of the ignition points — ignition_point","title":"Calculation of the ignition points — ignition_point","text":"function calculates ignition points clusters.","code":""},{"path":"/reference/ignition_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculation of the ignition points — ignition_point","text":"","code":"ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, ignitionCenter)"},{"path":"/reference/ignition_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculation of the ignition points — ignition_point","text":"lon Numeric. vector longitude values. lat Numeric. vector latitude values. obsTime Date/Datetime/Numeric. vector observed time. timeUnit Character. One \"s\" (seconds), \"m\"(minutes), \"h\"(hours), \"d\"(days) \"n\"(numeric). timeID Integer (>=1). vector time indexes. membership Integer. vector membership labels. ignitionCenter Character. Method calculating ignition points, one \"mean\" \"median\".","code":""},{"path":"/reference/ignition_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculation of the ignition points — ignition_point","text":"data frame ignition points membership : Membership labels. lon : Longitude ignition points. lat : Latitude ignition points. obsTime : Observed time ignition points. timeID : Time indexes. obsInCluster : Number observations cluster. clusterTimeLen : Length time cluster. clusterTimeLenUnit : Unit length time cluster.","code":""},{"path":"/reference/ignition_point.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculation of the ignition points — ignition_point","text":"details clustering algorithm argument timeUnit, timeID ignitionCenter, please check documentation hotspot_cluster(). function performs step 5 clustering algorithm. calculates ignition points. cluster, multiple earliest hot spots, ignitionCenter \"mean\", centroid hot spots used ignition point. ignitionCenter \"median\", median longitude median latitude hot spots used.","code":""},{"path":"/reference/ignition_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculation of the ignition points — ignition_point","text":"","code":"# Define lon, lat, obsTime, timeID and membership for 10 observations lon <- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,           141.16, 141.12, 141.14) lat <- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,          -37.14, -37.16, -37.16) obsTime <- c(rep(1, 5), rep(26, 5)) timeUnit <- \"n\" timeID <- c(rep(1, 5), rep(26, 5)) membership <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2)  # Calculate the ignition points using different methods ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, \"mean\") #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 5 #> ℹ average duration : 0 numeric #>   membership     lon     lat obsTime timeID obsInCluster clusterTimeLen #> 1          1 141.132 -37.112       1      1            5              0 #> 2          2 141.136 -37.148      26     26            5              0 #>   clusterTimeLenUnit #> 1                  n #> 2                  n ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, \"median\") #>  #> ── ignitionCenter = \"median\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 5 #> ℹ average duration : 0 numeric #>   membership    lon    lat obsTime timeID obsInCluster clusterTimeLen #> 1          1 141.14 -37.12       1      1            5              0 #> 2          2 141.14 -37.14      26     26            5              0 #>   clusterTimeLenUnit #> 1                  n #> 2                  n"},{"path":"/reference/local_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering hot spots spatially — local_clustering","title":"Clustering hot spots spatially — local_clustering","text":"function clusters hot spots spatially.","code":""},{"path":"/reference/local_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering hot spots spatially — local_clustering","text":"","code":"local_clustering(lon, lat, adjDist)"},{"path":"/reference/local_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering hot spots spatially — local_clustering","text":"lon Numeric. vector longitude values. lat Numeric. vector latitude values. adjDist Numeric (>0). Distance tolerance. Unit metre.","code":""},{"path":"/reference/local_clustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering hot spots spatially — local_clustering","text":"Integer. vector membership labels.","code":""},{"path":"/reference/local_clustering.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clustering hot spots spatially — local_clustering","text":"details clustering algorithm argument adjDist, please check documentation hotspot_cluster(). function performs step 2 clustering algorithm. clusters hot spots given interval.","code":""},{"path":"/reference/local_clustering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering hot spots spatially — local_clustering","text":"","code":"# Define lon and lat for 10 observations lon <- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,           141.16, 141.12, 141.14) lat <- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,          -37.14, -37.16, -37.16)  # Cluster 10 hot spots with different values of adjDist local_clustering(lon, lat, 2000) #>  [1] 1 2 3 3 3 4 4 4 5 5 local_clustering(lon, lat, 3000) #>  [1] 1 1 1 1 1 1 1 1 1 1 local_clustering(lon, lat, 4000) #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"/reference/plot.spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting spatiotemporal clustering result — plot.spotoroo","title":"Plotting spatiotemporal clustering result — plot.spotoroo","text":"plot.spotoroo() plot method class spotoroo. simple wrapper plot_spotoroo().","code":""},{"path":"/reference/plot.spotoroo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting spatiotemporal clustering result — plot.spotoroo","text":"","code":"# S3 method for spotoroo plot(x, ...)"},{"path":"/reference/plot.spotoroo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting spatiotemporal clustering result — plot.spotoroo","text":"x spotoroo object. result call hotspot_cluster(). ... Additional arguments pass plot_spotoroo()","code":""},{"path":"/reference/plot.spotoroo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting spatiotemporal clustering result — plot.spotoroo","text":"ggplot object. plot clustering results.","code":""},{"path":"/reference/plot.spotoroo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting spatiotemporal clustering result — plot.spotoroo","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                            lon = \"lon\",                            lat = \"lat\",                            obsTime = \"obsTime\",                            activeTime = 24,                            adjDist = 3000,                            minPts = 4,                            minTime = 3,                            ignitionCenter = \"mean\",                            timeUnit = \"h\",                            timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────      # Different types of plots    # Default plot   plot(result, \"def\", bg = plot_vic_map())     # Fire movement plot   plot(result, \"mov\", cluster = 1:3, step = 3, bg = plot_vic_map())  # }"},{"path":"/reference/plot_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Default method of plotting the clustering results — plot_def","title":"Default method of plotting the clustering results — plot_def","text":"function plots clustering result spatially scatter plot.","code":""},{"path":"/reference/plot_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default method of plotting the clustering results — plot_def","text":"","code":"plot_def(   result,   cluster = \"all\",   hotspot = TRUE,   noise = FALSE,   ignition = TRUE,   from = NULL,   to = NULL,   bg = NULL )"},{"path":"/reference/plot_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default method of plotting the clustering results — plot_def","text":"result spotoroo object. result call hotspot_cluster(). cluster Character/Integer. \"\", plot clusters. integer vector given, plot corresponding clusters. hotspot Logical. TRUE, plot hot spots. noise Logical. TRUE, plot noise points. ignition Logical. TRUE, plot ignition points. OPTIONAL. Date/Datetime/Numeric. Start time. data type needs provided observed time. OPTIONAL. Date/Datetime/Numeric. End time. data type needs provided observed time. bg OPTIONAL. ggplot object. specified, plot onto object.","code":""},{"path":"/reference/plot_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default method of plotting the clustering results — plot_def","text":"ggplot object. plot clustering results.","code":""},{"path":"/reference/plot_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default method of plotting the clustering results — plot_def","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Plot a subset of clusters   plot_def(result, cluster = 1:3)     # Plot all clusters   plot_def(result, cluster = \"all\")  # }"},{"path":"/reference/plot_fire_mov.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting the fire movement — plot_fire_mov","title":"Plotting the fire movement — plot_fire_mov","text":"function plots fire movement. fire movement calculated get_fire_mov().","code":""},{"path":"/reference/plot_fire_mov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting the fire movement — plot_fire_mov","text":"","code":"plot_fire_mov(   result,   cluster = \"all\",   hotspot = TRUE,   from = NULL,   to = NULL,   step = 1,   bg = NULL )"},{"path":"/reference/plot_fire_mov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting the fire movement — plot_fire_mov","text":"result spotoroo object. result call hotspot_cluster(). cluster Character/Integer. \"\", plot clusters. integer vector given, plot corresponding clusters. hotspot Logical. TRUE, plot hot spots. OPTIONAL. Date/Datetime/Numeric. Start time. data type needs provided observed time. OPTIONAL. Date/Datetime/Numeric. End time. data type needs provided observed time. step Integer (>0). Step size used calculation fire movement. bg OPTIONAL. ggplot object. specified, plot onto object.","code":""},{"path":"/reference/plot_fire_mov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting the fire movement — plot_fire_mov","text":"ggplot object. plot fire movements.","code":""},{"path":"/reference/plot_fire_mov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting the fire movement — plot_fire_mov","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Plot cluster 1 to 4   plot_fire_mov(result, cluster = 1:4)     # Plot cluster 1 to 4, set step = 6   plot_fire_mov(result, cluster = 1:4, step = 6)  # }"},{"path":"/reference/plot_spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting spatiotemporal clustering result — plot_spotoroo","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"function takes spotoroo object produce plot clustering results. can called plot.spotoroo().","code":""},{"path":"/reference/plot_spotoroo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"","code":"plot_spotoroo(   result,   type = \"def\",   cluster = \"all\",   hotspot = TRUE,   noise = FALSE,   ignition = TRUE,   from = NULL,   to = NULL,   step = 1,   mainBreak = NULL,   minorBreak = NULL,   dateLabel = NULL,   bg = NULL )"},{"path":"/reference/plot_spotoroo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"result spotoroo object. result call hotspot_cluster(). type Character. Type plot. One \"def\" (default), \"timeline\" (timeline) \"mov\" (fire movement). cluster Character/Integer. \"\", plot clusters. integer vector given, plot corresponding clusters. Unavailable plot_timeline(). hotspot Logical. TRUE, plot hot spots. Unavailable plot_timeline(). noise Logical. TRUE, plot noise. used plot_def(). ignition Logical. TRUE, plot ignition points. used plot_def(). OPTIONAL. Date/Datetime/Numeric. Start time. data type needs provided observed time. OPTIONAL. Date/Datetime/Numeric. End time. data type needs provided observed time. step Integer (>=0). Step size used calculation fire movement. used plot_fire_mov(). mainBreak OPTIONAL. Character/Numeric. string/value giving difference major breaks. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_breaks. used plot_timeline(). minorBreak OPTIONAL. Character/Numeric. string/value giving difference minor breaks. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_minor_breaks. used plot_timeline(). dateLabel OPTIONAL. Character. string giving formatting specification labels. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_labels. Unavailable observed time numeric format. used plot_timeline(). bg OPTIONAL. ggplot object. specified, plot onto object. Unavailable plot_timeline().","code":""},{"path":"/reference/plot_spotoroo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"ggplot object. plot clustering results.","code":""},{"path":"/reference/plot_spotoroo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"type \"def\", clustering results plotted spatially. See also plot_def(). Available arguments: result type cluster ignition hotspot noise (OPTIONAL) (OPTIONAL) bg (OPTIONAL) type \"mov\", plot fire movement made. See also plot_fire_mov(). Available arguments: result type cluster hotspot (OPTIONAL) (OPTIONAL) step bg (OPTIONAL) type \"timeline\", plot timeline made. See also plot_timeline(). Available arguments: result type (OPTIONAL) (OPTIONAL) mainBreak (OPTIONAL) minorBreak (OPTIONAL) dateLabel (OPTIONAL)","code":""},{"path":"/reference/plot_spotoroo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting spatiotemporal clustering result — plot_spotoroo","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering result   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Different types of plots    # Default plot   plot_spotoroo(result, \"def\", bg = plot_vic_map())      # Fire movement plot   plot_spotoroo(result, \"mov\", cluster = 1:3, step = 3,                 bg = plot_vic_map())  # }"},{"path":"/reference/plot_timeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting the timeline of the fire and the noise — plot_timeline","title":"Plotting the timeline of the fire and the noise — plot_timeline","text":"function plots timeline fires noise points.","code":""},{"path":"/reference/plot_timeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting the timeline of the fire and the noise — plot_timeline","text":"","code":"plot_timeline(   result,   from = NULL,   to = NULL,   mainBreak = NULL,   minorBreak = NULL,   dateLabel = NULL )"},{"path":"/reference/plot_timeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting the timeline of the fire and the noise — plot_timeline","text":"result spotoroo object. result call hotspot_cluster(). OPTIONAL. Date/Datetime/Numeric. Start time. data type needs provided observed time. OPTIONAL. Date/Datetime/Numeric. End time. data type needs provided observed time. mainBreak OPTIONAL. Character/Numeric. string/value giving difference major breaks. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_breaks. minorBreak OPTIONAL. Character/Numeric. string/value giving difference minor breaks. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_minor_breaks. dateLabel OPTIONAL. Character. string giving formatting specification labels. observed time date/datetime format, value passed ggplot2::scale_x_date() ggplot2::scale_x_datetime() date_labels. Unavailable observed time numeric format.","code":""},{"path":"/reference/plot_timeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting the timeline of the fire and the noise — plot_timeline","text":"ggplot object. plot timeline.","code":""},{"path":"/reference/plot_timeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting the timeline of the fire and the noise — plot_timeline","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                           lon = \"lon\",                           lat = \"lat\",                           obsTime = \"obsTime\",                           activeTime = 24,                           adjDist = 3000,                           minPts = 4,                           minTime = 3,                           ignitionCenter = \"mean\",                           timeUnit = \"h\",                           timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────    # Plot timeline   plot_timeline(result,               mainBreak = \"1 week\",               minorBreak = \"1 day\",               dateLabel = \"%b %d\") #> ℹ `plot_timeline()`: Package ggbeeswarm version is not 0.6.0. `geom_point()` will be used insted to draw noise.  # }"},{"path":"/reference/plot_vic_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting map of Victoria, Australia — plot_vic_map","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"function plots map Victoria, Australia.","code":""},{"path":"/reference/plot_vic_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"","code":"plot_vic_map(...)"},{"path":"/reference/plot_vic_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"... arguments ignored.","code":""},{"path":"/reference/plot_vic_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"ggplot object. map Victoria, Australia.","code":""},{"path":"/reference/plot_vic_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"Require package sf installed.","code":""},{"path":"/reference/plot_vic_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting map of Victoria, Australia — plot_vic_map","text":"","code":"if (requireNamespace(\"sf\", quietly = TRUE)) {   plot_vic_map() }"},{"path":"/reference/print.spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing spatiotemporal clustering result — print.spotoroo","title":"Printing spatiotemporal clustering result — print.spotoroo","text":"print.spotoroo() print method class spotoroo.","code":""},{"path":"/reference/print.spotoroo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing spatiotemporal clustering result — print.spotoroo","text":"","code":"# S3 method for spotoroo print(x, ...)"},{"path":"/reference/print.spotoroo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing spatiotemporal clustering result — print.spotoroo","text":"x spotoroo object. result call hotspot_cluster(). ... Additional arguments ignored.","code":""},{"path":"/reference/print.spotoroo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Printing spatiotemporal clustering result — print.spotoroo","text":"return value, called side effects","code":""},{"path":"/reference/print.spotoroo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Printing spatiotemporal clustering result — print.spotoroo","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                            lon = \"lon\",                            lat = \"lat\",                            obsTime = \"obsTime\",                            activeTime = 24,                            adjDist = 3000,                            minPts = 4,                            minTime = 3,                            ignitionCenter = \"mean\",                            timeUnit = \"h\",                            timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────     # print the results   print(result) #> ℹ spotoroo object: 6 clusters | 1070 hot spots (including noise points) # }"},{"path":"/reference/spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"spotoroo: spatiotemporal clustering in R of hot spot — spotoroo","title":"spotoroo: spatiotemporal clustering in R of hot spot — spotoroo","text":"package clustering satellite hot spots detecting fire ignition points.","code":""},{"path":"/reference/spotoroo.html","id":"authors","dir":"Reference","previous_headings":"","what":"Authors","title":"spotoroo: spatiotemporal clustering in R of hot spot — spotoroo","text":"Weihao Li llreczx@gmail.com Dianne Cook dicook@monash.edu Emily Dodwell emdodwell@gmail.com","code":""},{"path":"/reference/spotoroo.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"spotoroo: spatiotemporal clustering in R of hot spot — spotoroo","text":"spotoroo package provides 13 important functions: hotspot_cluster() global_clustering() local_clustering() handle_noise() ignition_point() get_fire_mov() plot.spotoroo() plot_spotoroo() plot_def() plot_fire_mov() plot_timeline() plot_vic_map() summary.spotoroo() summary_spotoroo() print.spotoroo() transform_time_id() dist_point_to_vector() spotoroo package provides 2 external data objects: hotspots vic_map","code":""},{"path":"/reference/summary.spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing spatiotemporal clustering result — summary.spotoroo","title":"Summarizing spatiotemporal clustering result — summary.spotoroo","text":"summary.spotoroo() summary method class spotoroo. simple wrapper summary_spotoroo().","code":""},{"path":"/reference/summary.spotoroo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing spatiotemporal clustering result — summary.spotoroo","text":"","code":"# S3 method for spotoroo summary(object, ...)"},{"path":"/reference/summary.spotoroo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing spatiotemporal clustering result — summary.spotoroo","text":"object spotoroo object. result call hotspot_cluster(). ... Additional arguments pass summary_spotoroo()","code":""},{"path":"/reference/summary.spotoroo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing spatiotemporal clustering result — summary.spotoroo","text":"return value, called side effects","code":""},{"path":"/reference/summary.spotoroo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing spatiotemporal clustering result — summary.spotoroo","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                            lon = \"lon\",                            lat = \"lat\",                            obsTime = \"obsTime\",                            activeTime = 24,                            adjDist = 3000,                            minPts = 4,                            minTime = 3,                            ignitionCenter = \"mean\",                            timeUnit = \"h\",                            timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────     # Make a summary   summary(result) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: ALL #> OBSERVATIONS: 1070 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-07 22:50:00 #>  #>  #> ── Clusters  #> ℹ Number of clusters: 6 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.0       131.0       176.7       233.2       256.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.2       118.2       131.9       146.1       148.3 #>  #> ── Hot spots (excluding noise)  #> ℹ Number of hot spots: 1060 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2840.3      5058.2      6981.6     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        25.2        62.5        98.2       148.3 #>  #> ── Noise  #> ℹ Number of noise points: 10 (0.93 %) #>  #>  #> ──────────────────────────────────────────────────────────────────────────────── # }"},{"path":"/reference/summary_spotoroo.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing spatiotemporal clustering results — summary_spotoroo","title":"Summarizing spatiotemporal clustering results — summary_spotoroo","text":"function takes spotoroo object produce summary clustering results. can called summary.spotoroo().","code":""},{"path":"/reference/summary_spotoroo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing spatiotemporal clustering results — summary_spotoroo","text":"","code":"summary_spotoroo(result, cluster = \"all\")"},{"path":"/reference/summary_spotoroo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing spatiotemporal clustering results — summary_spotoroo","text":"result spotoroo object. result call hotspot_cluster(). cluster Character/Integer. \"\", summarize clusters. integer vector given, summarize corresponding clusters.","code":""},{"path":"/reference/summary_spotoroo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing spatiotemporal clustering results — summary_spotoroo","text":"return value, called side effects","code":""},{"path":"/reference/summary_spotoroo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing spatiotemporal clustering results — summary_spotoroo","text":"","code":"# \\donttest{    # Time consuming functions (>5 seconds)     # Get clustering results   result <- hotspot_cluster(hotspots,                            lon = \"lon\",                            lat = \"lat\",                            obsTime = \"obsTime\",                            activeTime = 24,                            adjDist = 3000,                            minPts = 4,                            minTime = 3,                            ignitionCenter = \"mean\",                            timeUnit = \"h\",                            timeStep = 1) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `hotspot_cluster()` ── #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 970 time indexes found #>  #> ── activeTime = 24 time indexes | adjDist = 3000 meters  #> ✔ Cluster #> ℹ 16 clusters found (including noise) #>  #> ── minPts = 4 hot spots | minTime = 3 time indexes  #> ✔ Handle noise #> ℹ 6 clusters left #> ℹ noise proportion : 0.935 % #>  #> ── ignitionCenter = \"mean\"  #> ✔ Compute ignition points for clusters #> ℹ average hot spots : 176.7 #> ℹ average duration : 131.9 hours #>  #> ── Time taken = 0 mins 1 sec for 1070 hot spots  #> ℹ 0.001 secs per hot spot #>  #> ────────────────────────────────────────────────────────────────────────────────     # Make a summary of all clusters   summary_spotoroo(result) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: ALL #> OBSERVATIONS: 1070 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-07 22:50:00 #>  #>  #> ── Clusters  #> ℹ Number of clusters: 6 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.0       131.0       176.7       233.2       256.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        111.2       118.2       131.9       146.1       148.3 #>  #> ── Hot spots (excluding noise)  #> ℹ Number of hot spots: 1060 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2840.3      5058.2      6981.6     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        25.2        62.5        98.2       148.3 #>  #> ── Noise  #> ℹ Number of noise points: 10 (0.93 %) #>  #>  #> ────────────────────────────────────────────────────────────────────────────────    # Make a summary of cluster 1 to 3   summary_spotoroo(result, 1:3) #>  #> ──────────────────────────────── SPOTOROO 0.1.2 ──────────────────────────────── #>  #> ── Calling Core Function : `summary_spotoroo()` ── #>  #> CLUSTERS: 1 2 3 #> OBSERVATIONS: 447 #> FROM: 2019-12-29 13:10:00 #> TO:   2020-02-01 05:20:00 #>  #>  #> ── Clusters  #> ℹ Number of clusters: 3 #>  #> Observations in cluster #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        126.0       136.0       145.7       155.5       165.0 #> Duration of cluster (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>        116.2       131.2       136.9       147.3       148.3 #>  #> ── Hot spots (excluding noise)  #> ℹ Number of hot spots: 437 #>  #> Distance to ignition points (m) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0      2222.7      4788.2      6944.3     13452.7 #> Time from ignition (hours) #>         Min.     1st Qu.        Mean     3rd Qu.        Max. #>          0.0        14.0        61.3        97.5       148.3 #>  #> ──────────────────────────────────────────────────────────────────────────────── # }"},{"path":"/reference/transform_time_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Transforming a series of time or datetime to time indexes — transform_time_id","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"function transforms series time datetime time indexes.","code":""},{"path":"/reference/transform_time_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"","code":"transform_time_id(obsTime, timeUnit, timeStep)"},{"path":"/reference/transform_time_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"obsTime Date/Datetime/Numeric. vector observed time hot spots. timeUnit \"n\", obsTime needs numeric vector, otherwise, needs date datetime format. timeUnit Character. unit time, one \"s\" (seconds), \"m\"(minutes), \"h\"(hours), \"d\"(days) \"n\"(numeric). timeStep Numeric (>0). Number units timeUnit time step.","code":""},{"path":"/reference/transform_time_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"Integer. vector time indexes.","code":""},{"path":"/reference/transform_time_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"earliest time assigned time index 1. difference time earliest time transformed using timeUnit divided timeStep. differences floored integer used time indexes.","code":""},{"path":"/reference/transform_time_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transforming a series of time or datetime to time indexes — transform_time_id","text":"","code":"# Define obsTime obsTime <- as.Date(c(\"2020-01-01\",                      \"2020-01-02\",                      \"2020-01-04\"))  # Transform it to time index under different settings transform_time_id(obsTime, \"h\", 1) #>  #> ── \"1\" time index = 1 hour  #> ✔ Transform observed time → time indexes #> ℹ 73 time indexes found #> [1]  1 25 73 transform_time_id(obsTime, \"m\", 60) #>  #> ── \"1\" time index = 60 mins  #> ✔ Transform observed time → time indexes #> ℹ 73 time indexes found #> [1]  1 25 73 transform_time_id(obsTime, \"s\", 3600) #>  #> ── \"1\" time index = 3600 secs  #> ✔ Transform observed time → time indexes #> ℹ 73 time indexes found #> [1]  1 25 73  # Define numeric obsTime obsTime <- c(1,              1.5,              4.5,              6)  # Transform it to time index under different settings transform_time_id(obsTime, \"n\", 1) #>  #> ── \"1\" time index = 1 numeric  #> ✔ Transform observed time → time indexes #> ℹ 6 time indexes found #> [1] 1 1 4 6 transform_time_id(obsTime, \"n\", 1.5) #>  #> ── \"1\" time index = 1.5 numeric  #> ✔ Transform observed time → time indexes #> ℹ 4 time indexes found #> [1] 1 1 3 4"},{"path":"/reference/vic_map.html","id":null,"dir":"Reference","previous_headings":"","what":"simple features map of Victoria — vic_map","title":"simple features map of Victoria — vic_map","text":"dataset containing simple features Victoria, Australia.","code":""},{"path":"/reference/vic_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simple features map of Victoria — vic_map","text":"","code":"vic_map"},{"path":"/reference/vic_map.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"simple features map of Victoria — vic_map","text":"\"sf\" object 1 row.","code":""},{"path":"/reference/vic_map.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"simple features map of Victoria — vic_map","text":"https://www.naturalearthdata.com/","code":""},{"path":"/reference/vic_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"simple features map of Victoria — vic_map","text":"dataset obtained via following codes:library(rnaturalearth)au_map <- ne_states(country = \"Australia\", returnclass = \"sf\")vic_map <- au_map[7,]$geometry","code":""},{"path":"/news/index.html","id":"spotoroo-012-devel","dir":"Changelog","previous_headings":"","what":"spotoroo 0.1.2-devel","title":"spotoroo 0.1.2-devel","text":"CRAN release: 2021-11-10 Fixed bug hotspot_cluster printed incorrect plural form noun via cli. Fixed bug summary_spotoroo printed incorrect plural form noun via cli.","code":""},{"path":"/news/index.html","id":"spotoroo-012","dir":"Changelog","previous_headings":"","what":"spotoroo 0.1.2","title":"spotoroo 0.1.2","text":"CRAN release: 2021-11-10 Fixed bug hotspot_to_ignition caused problems time calculation noise points. Fixed bug plot_timeline caused problems counting number fires. Fixed aspect ratio plot_fire_mov. now equals cos(mean(range(lat))*pi/180).","code":""},{"path":"/news/index.html","id":"spotoroo-011","dir":"Changelog","previous_headings":"","what":"spotoroo 0.1.1","title":"spotoroo 0.1.1","text":"CRAN release: 2021-03-31 Fixed bug plot_vic_map() caused problems older version spatial packages.","code":""},{"path":"/news/index.html","id":"spotoroo-010","dir":"Changelog","previous_headings":"","what":"spotoroo 0.1.0","title":"spotoroo 0.1.0","text":"CRAN release: 2021-03-22 First release Added 13 exported functions hotspot_cluster() global_clustering() local_clustering() handle_noise() ignition_point() get_fire_mov() plot.spotoroo() plot_spotoroo() plot_def() plot_fire_mov() plot_timeline() plot_vic_map() summary.spotoroo() summary_spotoroo() print.spotoroo() transform_time_id() dist_point_to_vector() Added 2 data objects hotspots vic_map","code":""},{"path":"/news/index.html","id":"spotoroo-0009000","dir":"Changelog","previous_headings":"","what":"spotoroo 0.0.0.9000","title":"spotoroo 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
